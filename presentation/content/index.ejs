<section>
  <h1>Elixir</h1>

  <small>
    Yevhen Shemet<br />
    github: <a target="_blank" href="https://github.com/yevhene/present-elixir">yevhene/present-elixir</a>
  </small>
</section>

<section>
  <h3>Erlang</h3>

  <section>
    <h4>History</h3>

    <div>It was originally a proprietary language within <b>Ericsson</b>, developed by <b>Joe Armstrong</b>, <b>Robert Virding</b> and <b>Mike Williams</b> in <i>1986</i>, but was <b>released as open source in 1998</b>. Erlang/OTP is supported and maintained by the OTP product unit at Ericsson.</div>
  </section>

  <section>
    <h4>History</h3>

    <div>The name <b>"Erlang"</b>, attributed to <b>Bjarne Däcker</b>, has been presumed by those working on the telephony switches (for whom the language was designed) to be a reference to <b>Danish mathematician and engineer Agner Krarup Erlang</b> as well as a syllabic abbreviation of <b>"Ericsson Language"</b>.</div>
  </section>

  <section>
    <h4>Functional</h4>

    <ul>
      <li>Immutability</li>
      <li>Pattern Matching (also Binary)</li>
      <li>Pure functions (preferred)</li>
      <li>Recursion (also Tail)</li>
    </ul>
  </section>

  <section>
    <h4>Scalable</h4>

    <ul>
      <li>Parallel</li>
      <li>Distributed</li>
      <li>Can fully consume all your resources</li>
    </ul>

    <div><i>Demo: ring</i></div>
  </section>

  <section>
    <h4>Actor-based</h4>

    <ul>
      <li>Every process has event loop</li>
      <li>Processes communicate through messages</li>
      <li>Message waits in "mailbox" utill it is processed</li>
      <li>Process decides when and how to interpret message</li>
    </ul>

    <div><i>True OOP</i></div>
  </section>

  <section>
    <h4>Supervision Trees</h4>

    <img src="images/supervision-trees.png" />

    <div><a href="https://bitbucket.org/ferd/chut"><i>https://bitbucket.org/</i>ferd/chut</a></div>
  </section>

  <section>
    <h4>Reliable</h4>

    <ul>
      <li>9x9 Reliability (99.9999999% &gt; 6σ)</li>
      <li>Supervision Trees</li>
      <li>Let if Fall</li>
      <li>Hot Deploy</li>
    </ul>
  </section>

  <section>
    <h4>Mature</h4>

    <ul>
      <li>Ecosystem</li>
      <li>BEAM</li>
      <li>OTP</li>
      <li>Tools</li>
      <li>Libraries</li>
    </ul>
  </section>

  <section>
    <h4>Widely adopted</h4>

    <ul>
      <li>Amazon</li>
      <li>Facebook</li>
      <li>WhatsApp</li>
      <li>Ericsson</li>
    </ul>
  </section>

  <section>
    <h4>Complex heritage</h4>

    <ul>
      <li>Focused on Telecom</li>
      <li>Prolog derived (;,.)</li>
      <li>Single assingment</li>
      <li>Hard to use UTF-8</li>
      <li>Alien syntax</li>
    </ul>
  </section>

  <section>
    <h4>Summary</h4>

    <h5>Beautiful inside scary outside</h5>
  </section>
</section>

<section>
  <h3>Elixir</h3>

  <section>
    <h4>History</h4>

    <div><b>José Valim</b> is the creator of the <b>Elixir</b> programming language, an R&amp;D project of Plataformatec (at <b>2011</b>). His goals were to enable higher extensibility and productivity in the Erlang VM while keeping compatibility with Erlang's ecosystem.</div>
  </section>
</section>

<section>
  <h3>Elixir: Syntax</h3>

  <section>
    <h4>Let's mix in some neat Ruby syntax</h4>
  </section>

  <section>
    <h4>Hello World</h4>

    <pre><code class="hljs" data-trim contenteditable>
IO.puts "Hello World!"
    </code></pre>

    <pre><code class="hljs" data-trim contenteditable>
iex
    </code></pre>
  </section>

  <section>
    <h4>Functions and Modules</h4>

    <pre><code class="hljs" data-trim contenteditable>
defmodule Greeter do
  def hello(name) do
    IO.puts "Hello #{name}!"
  end
end

Greeter.hello("World")
    </code></pre>

    <pre><code class="hljs" data-trim contenteditable>
elixir hello-fn.exs
    </code></pre>
  </section>

  <section>
    <h4>Short Notation</h4>

    <pre><code class="hljs" data-trim contenteditable>
defmodule Greeter, do: def hello(name), do: IO.puts "Hello #{name}!"

Greeter.hello("World")
    </code></pre>
  </section>

  <section>
    <h4>Multiple clauses</h4>

    <pre><code class="hljs" data-trim contenteditable>
    </code></pre>
  </section>

  <section>
    <h4>Recursion</h4>

    <pre><code class="hljs" data-trim contenteditable>
defmodule Fib do
  def fib(0), do: 0
  def fib(1), do: 1
  def fib(n), do: fib(n - 1) + fib(n - 2)
end

IO.puts Fib.fib(10)
    </code></pre>
  </section>

  <section>
    <h4>Guards</h4>

    <pre><code class="hljs" data-trim contenteditable>
defmodule Fib do
  def fib(n) when n &gt; 40, do: raise "You will never get it"
  def fib(0), do: 0
  def fib(1), do: 1
  def fib(n), do: fib(n - 1) + fib(n - 2)
end

IO.puts Fib.fib(41)
    </code></pre>
  </section>

  <section>
    <h4>Tail call recursion</h4>

    <pre><code class="hljs" data-trim contenteditable>
defmodule Fib do
  def fib(a), do: fib(1, 1, a)

  defp fib(a, _, 0 ), do: a
  defp fib(a, b, n), do: fib(b, a + b, n - 1)
end

IO.puts Fib.fib(80)
    </code></pre>
  </section>

  <section>
    <h4>List destruction</h4>

    <pre><code class="hljs" data-trim contenteditable>
defmodule Collection do
  def len([]), do: 0
  def len([_head | tail]), do: 1 + len(tail)
end

IO.puts Collection.len([1, 2, 3])
    </code></pre>
  </section>

  <section>
    <h4>Conditionals (cond)</h4>

    <pre><code class="hljs" data-trim contenteditable>
cond do
  2 + 2 == 5 -&gt;
    "This will not be true"
  2 * 2 == 3 -&gt;
    "Nor this"
  1 + 1 == 2 -&gt;
    "But this will"
end
    </code></pre>
  </section>

  <section>
    <h4>Conditionals (case)</h4>

    <pre><code class="hljs" data-trim contenteditable>
case {1, 2, 3} do
  {1, x, 3} when x &gt; 0 -&gt;
    "Will match"
  [1 | _] -&gt;
    "Will not match"
  _ -&gt;
    "Would match, if guard condition were not satisfied"
end
    </code></pre>
  </section>

  <section>
    <h4>Conditionals (if)</h4>

    <pre><code class="hljs" data-trim contenteditable>
if x &gt; 0 do
  "This won't be seen"
else
  "This will"
end
    </code></pre>

    <pre><code class="hljs" data-trim contenteditable>
if x &gt; 0, do: "This won't be seen", else: "This will"
    </code></pre>
  </section>

  <section>
    <h4>Other complex data types</h4>

    <pre><code class="hljs" data-trim contenteditable>
{:ok, "result"} # Tuple

[{:a, 8}, {:b, 9}] == [a: 8, b: 9] # Keyword list

%{a: 8, b: 9} # Map
    </code></pre>
  </section>

  <section>
    <h4>Pipe operator</h4>

    <pre><code class="hljs" data-trim contenteditable>
string = "hello, world!"
words = String.split(string, " ")
capitalized_words = Enum.map(words, &amp;String.capitalize/1)
Enum.join(capitalized_words, " ")
    </code></pre>

    <pre><code class="hljs" data-trim contenteditable>
"hello, world!"
|&gt; String.split(" ")
|&gt; Enum.map(&amp;String.capitalize/1)
|&gt; Enum.join
    </code></pre>
  </section>

  <section>
    <h4>Streams</h4>

    <pre><code class="hljs" data-trim contenteditable>
0
|&gt; Stream.iterate(&amp;(&amp;1 + 1))
|&gt; Stream.filter(fn x -&gt; rem(x, 2) == 0 end)
|&gt; Stream.take(10)
|&gt; Enum.map(&amp;IO.puts/1)
    </code></pre>
  </section>

  <section>
    <h4>Structs</h4>

    <pre><code class="hljs" data-trim contenteditable>
defmodule User do
  defstruct name: "John", age: 27
end
    </code></pre>

    <pre><code class="hljs" data-trim contenteditable>
user = %User{age: 27, name: "John"}

%{age: x} = user

IO.puts x
    </code></pre>
  </section>

  <section>
    <h4>Protocols</h4>

    <pre><code class="hljs" data-trim contenteditable>
defprotocol String.Chars do
  def to_string(term)
end
    </code></pre>

    <pre><code class="hljs" data-trim contenteditable>
defimpl String.Chars, for: User do
  def to_string(%User{name: name}), do: name
end
    </code></pre>

    <pre><code class="hljs" data-trim contenteditable>
user = %User{}
IO.puts user #=&gt; John
    </code></pre>
  </section>

  <section>
    <h4>Summary</h4>

    <h5>Best for building pipes of data processing</h5>
  </section>
</section>

<section>
  <h3>Elixir: Metaprogramming</h3>

  <section>
    <h4>Let's mix in some awesome LISP metaprogramming</h4>
  </section>

  <section>
    <h4>TODO</h4>

    <pre><code class="hljs" data-trim contenteditable>
- defmacro
- AST matching
    </code></pre>
  </section>
</section>

<section>
  <h3>Phoenix</h3>

  <section>
    <h4>Let's mix in some Ruby on Rails goodies</h4>
  </section>

  <section>
    <h4>TODO</h4>

    <pre><code class="hljs" data-trim contenteditable>
- Rails-alike
- Ecto
- Plug
- Demo: novel
    </code></pre>
  </section>
</section>

<section>
  <h3>References</h3>

  <ul>
    <li><a href="https://learnyousomeerlang.com">https://learnyousomeerlang.com</a></li>
  </ul>
</section>

<section>
  <h2>Questions?</h2>
</section>
